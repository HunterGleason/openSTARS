---
output:
  html_document:
    keep_md: yes
---
openSTARS
=============

```{r echo=FALSE}
knitr::opts_chunk$set(
  warning = FALSE,
  message = FALSE,
  collapse = TRUE,
  comment = "#>"
)
```


`openSTARS` is an open source implementation of the STARS toolbox (Peterson & Ver Hoef, 2014) using R and GRASS GIS.
It prepares the .ssn object needed for the SSN package.
Currently a DEM is used to derive stream networks (in contrast to STARS, which can clean an existing stream network).

For more information on STARS and SSN, see [their webpage](http://www.fs.fed.us/rm/boise/AWAE/projects/SpatialStreamNetworks.shtml).

Peterson, E. E., & Ver Hoef, J. M. (2014). STARS: An ArcGIS Toolset Used to Calculate the Spatial Information Needed to Fit Spatial Statistical Models to Stream Network Data. J Stat Softw, 56(2), 1–17.


### Installation
A functional installation of [GRASS GIS (>=7.0)](https://grass.osgeo.org/#) with installed addons [r.stream.basins](https://grass.osgeo.org/grass70/manuals/addons/r.stream.basins.html), [r.stream.distance](https://grass.osgeo.org/grass70/manuals/addons/r.stream.distance.html) and [r.stream.order](https://grass.osgeo.org/grass70/manuals/addons/r.stream.order.html) is needed.

The openSTARS package can be installed from github using

```{r install, eval=FALSE}
install.packages("devtools")
devtools::install_github("edild/openSTARS")
library('openSTARS')
```


### Basic usage

#### Initiate a ephemeral GRASS session:
```{r setup_grass}
library(openSTARS)
initGRASS(gisBase = "/usr/lib/grass70/",
          home = tempdir(),
          override = TRUE)
```

#### Load DEM and sites into GRASS:

```{r import_data, warning=FALSE, message=FALSE}
dem_path <- system.file("extdata", "nc", "elev_ned_30m.tif", package = "openSTARS")
sites_path <- system.file("extdata", "nc", "sites_nc.shp", package = "openSTARS")

import_data(dem = dem_path, sites = sites_path)

gmeta()
```

The dem is loaded as raster names `dem`, the sites as vector named `sites_o`.
Here's how the data looks like:

```{r plot_data1, message=FALSE}
dem <- readRAST('dem', ignore.stderr = TRUE)
sites <- readVECT('sites_o', ignore.stderr = TRUE)
plot(dem, col = terrain.colors(20))
cols <- colorRampPalette(c("blue", 'red'))(length(sites$value))[rank(sites$value)]
points(sites, pch = 16, col = cols)
```

#### Derive streams from DEM:
```{r derive_streams, results='hide', message=FALSE, warning=FALSE}
derive_streams()
```

```{r derive_streams2}
streams <- readVECT('streams_v', ignore.stderr = TRUE)
plot(dem, col = terrain.colors(20))
lines(streams, col = 'blue')
points(sites, pch = 16, col = cols)
```

#### Prepare edges:

```{r prep_edges, results='hide', message=FALSE, warning=FALSE}
calc_edges()
```

```{r edges}
edges <- readVECT('edges', ignore.stderr = TRUE)
head(edges@data)
```

`edges` now holds the derived network plus attributes needed for SSN (segment id, network id, upstream distance ( distance from outlet), watershed area, river contributing area, toplogical dimension, segment length, distance from source)


#### Prepare sites:

```{r prep_sites, results='hide', message=FALSE, warning=FALSE}
calc_sites()
```

```{r sites}
sites <- readVECT('sites', ignore.stderr = TRUE)
edges <- readVECT('edges', ignore.stderr = TRUE)
plot(dem, col = terrain.colors(20))
lines(edges, col = 'blue')
points(sites, pch = 16, col = cols)
head(sites@data)
```

Now the sites are snapped to the network and additional attributes (pid, locID, netID, rid, upDist) are appended to the sites.

#### Setup prediction sites

[Currently not implemented]

#### Calculate binary IDs for each network

```{r calc_binary}
binaries <- calc_binary()
head(binaries[[1]])
```


#### Write all files ssn folder

```{r export}
ssn_dir <- file.path(tempdir(), 'nc.ssn')
ssn_dir
export_ssn(ssn_dir, binary = binaries)
list.files(ssn_dir)
```

#### Check ssn folder
```{r check_ssn}
check_ssn(ssn_dir)
```

#### Create prediction sites
```{r create_pred, include=FALSE, eval=FALSE}
preds <- create_pred(ssn_dir, 'pred_regular', n = 500, type = 'regular')
sites <- readOGR(ssn_dir, 'sites')
edges <- readOGR(ssn_dir, 'edges')
preds <- readOGR(ssn_dir, 'pred_regular')
plot(edges)
points(sites)
points(preds, pch = 4)
```

#### Try with SSN package
```{r ssn_test}
library(SSN)
# import
ssn_obj <- importSSN(ssn_dir, predpts = 'pred_regular', o.write = TRUE)
plot(ssn_obj, 'value')

# Create Distance Matrix
createDistMat(ssn_obj, o.write = TRUE)
dmats <- getStreamDistMat(ssn_obj)

ssn_obj.Torg <- Torgegram(ssn_obj, "value", nlag = 20, maxlag = 15000)
plot(ssn_obj.Torg)

names(ssn_obj@data)
names(ssn_obj)
ssn_obj <- additive.function(ssn_obj, "H2OArea", "computed.afv")

# non-spatial model
ssn_obj.glmssn0 <- glmssn(value ~ 1, ssn.object = ssn_obj,
                            CorModels = NULL)
summary(ssn_obj.glmssn0)
# same as
summary(lm(value ~ 1, getSSNdata.frame(ssn_obj)))


# # # spatial model
# doesn't work
ssn_obj.glmssn1 <- glmssn(value ~ 1, ssn.object = ssn_obj,
                            CorModels = c("Exponential.Euclid"),
                          addfunccol = "computed.afv")
# other corModels do not work (taildown, tailup... why?)
summary(ssn_obj.glmssn1)
```


### Contributors

+ [Eduard Szöcs](https://github.com/EDiLD)

### Want to contribute?

Checkout our [contribution guide here](https://github.com/edild/openSTARS/blob/master/CONTRIBUTING.md).

### Meta

* Please [report any issues, bugs or feature requests](https://github.com/edild/openSTARS/issues).
* License: MIT
