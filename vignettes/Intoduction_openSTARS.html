<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Mira Kattwinkel" />

<meta name="date" content="2017-01-19" />

<title>Introduction to openSTARS</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>



<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">Introduction to openSTARS</h1>
<h4 class="author"><em>Mira Kattwinkel</em></h4>
<h4 class="date"><em>2017-01-19</em></h4>



<p><code>openSTARS</code> is an open source implementation of the STARS toolbox (Peterson &amp; Ver Hoef, 2014) using R and GRASS GIS. It prepares the .ssn object needed for the SSN package. A digital elevation model (DEM) is used to derive stream networks, in contrast to STARS, which can clean an existing stream network). The reason for this is that existing stream networks (e.g. obtained as shape files) very often contain loops and dead ends, which make it hard to built a valid topography for them.</p>
<p>For more information on STARS and SSN, see <a href="http://www.fs.fed.us/rm/boise/AWAE/projects/SpatialStreamNetworks.shtml">their web page</a>.</p>
<p>Peterson, E. E., &amp; Ver Hoef, J. M. (2014). STARS: An ArcGIS Toolset Used to Calculate the Spatial Information Needed to Fit Spatial Statistical Models to Stream Network Data. J Stat Softw, 56(2), 1–17.</p>
<div id="installation-and-loading" class="section level3">
<h3>Installation and loading</h3>
<p>A functional installation of <a href="https://grass.osgeo.org/#">GRASS GIS (&gt;=7.0)</a> with installed add-ons <a href="https://grass.osgeo.org/grass70/manuals/addons/r.stream.basins.html">r.stream.basins</a>, <a href="https://grass.osgeo.org/grass70/manuals/addons/r.stream.distance.html">r.stream.distance</a>, <a href="https://grass.osgeo.org/grass70/manuals/addons/r.stream.order.html">r.stream.order</a> and <a href="https://grass.osgeo.org/grass70/manuals/addons/r.hydrodem.html">r.hydrodem</a> is needed. These add-ons can be installed from within GRASS using the console and g.extension or in the GUI under Settings / Addons extensions / Install extensions from add-ons under ‘raster’.</p>
<p><strong>UPDATE!!</strong></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">install.packages</span>(<span class="st">&quot;devtools&quot;</span>)
devtools::<span class="kw">install_github</span>(<span class="st">&quot;edild/openSTARS&quot;</span>)
<span class="kw">library</span>(<span class="st">&quot;openSTARS&quot;</span>)</code></pre></div>
</div>
<div id="basic-usage" class="section level3">
<h3>Basic usage</h3>
<div id="initiate-an-ephemeral-grass-session" class="section level4">
<h4>Initiate an ephemeral GRASS session</h4>
<p>First, a GRASS session must be initiated:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(openSTARS)
<span class="kw">initGRASS</span>(<span class="dt">gisBase =</span> <span class="st">&quot;/usr/lib/grass70/&quot;</span>,
          <span class="dt">home =</span> <span class="kw">tempdir</span>(),
          <span class="dt">override =</span> <span class="ot">TRUE</span>)</code></pre></div>
<p>Alternatively, the path to a specific GRASS database directory and a Location name can be provided.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(openSTARS)
<span class="kw">initGRASS</span>(<span class="dt">gisBase =</span> <span class="st">&quot;/usr/lib/grass70/&quot;</span>,
          <span class="dt">home =</span> <span class="kw">tempdir</span>(),
          <span class="dt">gisDbase =</span> <span class="st">&quot;./GRASSDB&quot;</span>,
          <span class="dt">location =</span> <span class="st">&quot;test_openSTARS&quot;</span>,
          <span class="dt">remove_GISRC =</span> T,
          <span class="dt">override =</span> <span class="ot">TRUE</span>)</code></pre></div>
</div>
<div id="setup-grass-and-load-data-into-grass" class="section level4">
<h4>Setup GRASS and load data into GRASS</h4>
<p>The path to the digital elevation model (DEM) and the observation sites must be provided. Additionally, the path to a stream network, which can be burnt into the DEM before extracting the streams, can be given.</p>
<p>First, <code>setup_grass_environment</code> prepares the GRASS environment by setting</p>
<ul>
<li>the projection to that one of the observation sites or to an epsg code provided</li>
<li>the region to the extent of the DEM.</li>
</ul>
<p>For more information on the concept of GRASS Locations, Mapsets etc. see the <a href="https://grass.osgeo.org/grass73/manuals/helptext.html">GRASS GIS Quickstart</a>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dem_path &lt;-<span class="st"> </span><span class="kw">system.file</span>(<span class="st">&quot;extdata&quot;</span>, <span class="st">&quot;nc&quot;</span>, <span class="st">&quot;elev_ned_30m.tif&quot;</span>, <span class="dt">package =</span> <span class="st">&quot;openSTARS&quot;</span>)
sites_path &lt;-<span class="st"> </span><span class="kw">system.file</span>(<span class="st">&quot;extdata&quot;</span>, <span class="st">&quot;nc&quot;</span>, <span class="st">&quot;sites_nc.shp&quot;</span>, <span class="dt">package =</span> <span class="st">&quot;openSTARS&quot;</span>)

<span class="kw">setup_grass_environment</span>(<span class="dt">dem =</span> dem_path, <span class="dt">sites =</span> sites_path)

<span class="kw">gmeta</span>()</code></pre></div>
<p>Then, use <code>import_data</code> to import all data into GRASS (DEM, observations sites and optionally stream network)</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">import_data</span>(<span class="dt">dem =</span> dem_path, <span class="dt">sites =</span> sites_path)</code></pre></div>
<p>The DEM is loaded into the GRASS database as raster map named <code>dem</code>, the sites as vector map named <code>sites_o</code> and the (optional) stream network as vector map named <code>streams_o</code>. Here’s how the data looks like:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dem &lt;-<span class="st"> </span><span class="kw">readRAST</span>(<span class="st">&quot;dem&quot;</span>, <span class="dt">ignore.stderr =</span> <span class="ot">TRUE</span>)
sites &lt;-<span class="st"> </span><span class="kw">readVECT</span>(<span class="st">&quot;sites_o&quot;</span>, <span class="dt">ignore.stderr =</span> <span class="ot">TRUE</span>)
<span class="kw">plot</span>(dem, <span class="dt">col =</span> <span class="kw">terrain.colors</span>(<span class="dv">20</span>))
cols &lt;-<span class="st"> </span><span class="kw">colorRampPalette</span>(<span class="kw">c</span>(<span class="st">&quot;blue&quot;</span>, <span class="st">&quot;red&quot;</span>))(<span class="kw">length</span>(sites$value))[<span class="kw">rank</span>(sites$value)]
<span class="kw">points</span>(sites, <span class="dt">pch =</span> <span class="dv">16</span>, <span class="dt">col =</span> cols)</code></pre></div>
</div>
<div id="derive-streams-from-dem" class="section level4">
<h4>Derive streams from DEM</h4>
<p>Next, the streams should be derived from the DEM.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">derive_streams</span>()</code></pre></div>
<p>An existing stream network (if provided to <code>import_data</code> before) can be burnt into the DEM to force the streams derived from the DEM to the existing one. Additionally, other specifications on how the streams shall be created can be provided (see <code>?derive_streams</code> and <a href="https://grass.osgeo.org/grass73/manuals/r.stream.extract.html">r.stream.extract</a> for details).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">derive_streams</span>(<span class="dt">burn =</span> <span class="dv">10</span>, <span class="dt">accum_threshold =</span> <span class="dv">1000</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dem &lt;-<span class="st"> </span><span class="kw">readRAST</span>(<span class="st">&quot;dem&quot;</span>, <span class="dt">ignore.stderr =</span> <span class="ot">TRUE</span>)
streams &lt;-<span class="st"> </span><span class="kw">readVECT</span>(<span class="st">&quot;streams_v&quot;</span>, <span class="dt">ignore.stderr =</span> <span class="ot">TRUE</span>)
<span class="kw">plot</span>(dem, <span class="dt">col =</span> <span class="kw">terrain.colors</span>(<span class="dv">20</span>))
<span class="kw">lines</span>(streams, <span class="dt">col =</span> <span class="st">&quot;blue&quot;</span>)
<span class="kw">points</span>(sites, <span class="dt">pch =</span> <span class="dv">16</span>, <span class="dt">col =</span> cols)</code></pre></div>
</div>
<div id="check-the-network" class="section level4">
<h4>Check the network</h4>
<p>Next, the stream network should be checked if there are stream segments with more than two inflows. This must be corrected because the .ssn object must not have such complex junctions. In the nc data set provided, there will be no complex junctions.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">cp &lt;-<span class="st"> </span><span class="kw">check_compl_junctions</span>()
if (cp)
  <span class="kw">correct_compl_junctions</span>()</code></pre></div>
</div>
<div id="prepare-edges" class="section level4">
<h4>Prepare edges</h4>
<p>Now, information needed for the .ssn object can be derived for the streams and stored in a new vector map <code>edges</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">calc_edges</span>()</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">edges &lt;-<span class="st"> </span><span class="kw">readVECT</span>(<span class="st">&quot;edges&quot;</span>, <span class="dt">ignore.stderr =</span> <span class="ot">TRUE</span>)
<span class="kw">head</span>(edges@data, <span class="dt">n=</span><span class="dv">4</span>)</code></pre></div>
<p><code>edges</code> now holds the derived network plus attributes needed for the .ssn object</p>
<ul>
<li>network identifier (netID)</li>
<li>reach identifier (rid)</li>
<li>stream segment length (length)</li>
<li>distance from the source (sourceDist)</li>
<li>upstream distance, i.e. distance from the outlet of the network to the outflow of the stream segment (upDist)</li>
<li>total catchment area (H2OArea)</li>
<li>reach contributing area (rcaArea)</li>
</ul>
<p>The additional fields hold information about the network: ‘next_str’ is the ‘stream’ this segment flows into, ‘prev_str01’ and ‘prev_str02’ are the two segments that flow into this segment.</p>
</div>
<div id="prepare-sites" class="section level4">
<h4>Prepare sites</h4>
<p>Often, survey sites do not lay exactly on the stream network (due to GPS imprecision, stream representation as lines, derivation of streams from a DEM, etc.). To assign an exact position of the sites on the network they are moved to the closest stream segment (snapped) using <a href="https://grass.osgeo.org/grass70/manuals/addons/r.stream.distance.html">v.distance</a>. Additionally, attributes needed for .ssn object are assigned:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">calc_sites</span>()
sites &lt;-<span class="st"> </span><span class="kw">readVECT</span>(<span class="st">&quot;sites&quot;</span>, <span class="dt">ignore.stderr =</span> <span class="ot">TRUE</span>)
<span class="kw">head</span>(sites@data)</code></pre></div>
<ul>
<li>point identifier (pid)</li>
<li>location identifier (locID)</li>
<li>network identifier (netID)</li>
<li>reach identifier of the edge segment the point lies on (rid)</li>
<li>upstream distance (upDist), i.e. the distance to the network outlet calculated using <a href="https://grass.osgeo.org/grass70/manuals/addons/r.stream.distance.html">r.stream.distance</a>.</li>
<li>distance ratio, i.e. the ratio of the distance from the outflow of the edge to the point along the edge and the total length of the edge segment (distRatio).</li>
</ul>
<p>Additional fields hold information on the snapping: distance of the original site to the closest edge (dist), i.e. how far the point was moved, and the new x and y coordinates (xm, ym). The filed ‘cat_edge’ gives the ‘cat’ of the stream segment the point lies on (equivalent to ‘rid’).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dem &lt;-<span class="st"> </span><span class="kw">readRAST</span>(<span class="st">&quot;dem&quot;</span>, <span class="dt">ignore.stderr =</span> <span class="ot">TRUE</span>)
sites &lt;-<span class="st"> </span><span class="kw">readVECT</span>(<span class="st">&quot;sites&quot;</span>, <span class="dt">ignore.stderr =</span> <span class="ot">TRUE</span>)
sites_orig &lt;-<span class="st"> </span><span class="kw">readVECT</span>(<span class="st">&quot;sites_o&quot;</span>, <span class="dt">ignore.stderr =</span> <span class="ot">TRUE</span>)
edges &lt;-<span class="st"> </span><span class="kw">readVECT</span>(<span class="st">&quot;edges&quot;</span>, <span class="dt">ignore.stderr =</span> <span class="ot">TRUE</span>)
<span class="kw">plot</span>(dem, <span class="dt">col =</span> <span class="kw">terrain.colors</span>(<span class="dv">20</span>))
<span class="kw">lines</span>(edges, <span class="dt">col =</span> <span class="st">&quot;blue&quot;</span>)
<span class="kw">points</span>(sites_orig, <span class="dt">pch =</span> <span class="dv">21</span>, <span class="dt">cex=</span><span class="fl">0.75</span>, <span class="dt">bg =</span> <span class="st">&quot;grey&quot;</span>)
<span class="kw">points</span>(sites, <span class="dt">pch =</span> <span class="dv">20</span>, <span class="dt">col =</span> <span class="st">&quot;black&quot;</span>)</code></pre></div>
</div>
<div id="prepare-prediction-sites" class="section level4">
<h4>Prepare prediction sites</h4>
<p>Prediction sites can be created along the streams. Either the distance between the sites must be provided (<code>dist</code>) or the approximate number of sites that shall be created (<code>nsites</code>). Additionally, the creation can be restricted to a certain networks (<code>netIDs</code>).</p>
<p>Similar as for the observation sites, attributes needed for .ssn object are assigned:</p>
<ul>
<li>point identifier (pid)</li>
<li>location identifier (locID)</li>
<li>network identifier (netID)</li>
<li>reach identifier of the edge segment the point lies on (rid)</li>
<li>upstream distance (upDist), i.e. the distance to the network outlet calculated using <a href="https://grass.osgeo.org/grass70/manuals/addons/r.stream.distance.html">r.stream.distance</a>.</li>
<li>distance ratio, i.e. the ratio of the distance from the outflow of the edge to the point along the edge and the total length of the edge segment (distRatio).</li>
</ul>
<p>The filed ‘cat_edge’ gives the ‘cat’ of the stream segment the point lies on (equivalent to ‘rid’).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">calc_prediction_sites</span>(<span class="dt">predictions =</span> <span class="st">&quot;preds&quot;</span>, <span class="dt">nsites =</span> <span class="dv">100</span>, <span class="dt">netIDs =</span> <span class="dv">15</span> )</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dem &lt;-<span class="st"> </span><span class="kw">readRAST</span>(<span class="st">&quot;dem&quot;</span>, <span class="dt">ignore.stderr =</span> <span class="ot">TRUE</span>)
sites &lt;-<span class="st"> </span><span class="kw">readVECT</span>(<span class="st">&quot;sites&quot;</span>, <span class="dt">ignore.stderr =</span> <span class="ot">TRUE</span>)
pred_sites &lt;-<span class="st"> </span><span class="kw">readVECT</span>(<span class="st">&quot;preds&quot;</span>, <span class="dt">ignore.stderr =</span> <span class="ot">TRUE</span>)
edges &lt;-<span class="st"> </span><span class="kw">readVECT</span>(<span class="st">&quot;edges&quot;</span>, <span class="dt">ignore.stderr =</span> <span class="ot">TRUE</span>)
<span class="kw">plot</span>(dem, <span class="dt">col =</span> <span class="kw">terrain.colors</span>(<span class="dv">20</span>))
<span class="kw">lines</span>(edges, <span class="dt">col =</span> <span class="st">&quot;blue&quot;</span>)
<span class="kw">points</span>(sites, <span class="dt">pch =</span> <span class="dv">21</span>, <span class="dt">cex=</span><span class="fl">0.75</span>, <span class="dt">bg =</span> <span class="st">&quot;grey&quot;</span>)
<span class="kw">points</span>(pred_sites, <span class="dt">pch =</span> <span class="dv">20</span>, <span class="dt">col =</span> <span class="st">&quot;black&quot;</span>)
<span class="kw">head</span>(pred_sites@data)</code></pre></div>
</div>
<div id="calculate-attributes-from-raster-maps" class="section level4">
<h4>Calculate attributes from raster maps</h4>
<p>Attributes (i.e. predictor variables for the .ssn object) can be calculated for observation and prediction sites. There are two ways to calculates attributes:</p>
<ol style="list-style-type: decimal">
<li>approximately as described in Peterson &amp; Ver Hoef, 2014: STARS: An ARCGIS Toolset Used to Calculate the Spatial Information Needed to Fit Spatial Statistical Models to Stream Network Data. J. Stat. Softw., 56 (2).</li>
<li>exactly by intersecting the catchment of each point with raster maps;</li>
</ol>
<p>For the approximate calculation, first attributes must be intersected with the sub-catchments of the stream segments and then they are calculated for each site based on the distance ratio of the point. Note that the sub-catchment area ‘H2OArea’ for each stream segment is calculated automatically in calc_edges.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># calculates slope from DEM as an example attribute</span>
<span class="kw">execGRASS</span>(<span class="st">&quot;r.slope.aspect&quot;</span>, <span class="dt">flags =</span> <span class="kw">c</span>(<span class="st">&quot;overwrite&quot;</span>,<span class="st">&quot;quiet&quot;</span>),
          <span class="dt">parameters =</span> <span class="kw">list</span>(
            <span class="dt">elevation =</span> <span class="st">&quot;dem&quot;</span>,
            <span class="dt">slope =</span> <span class="st">&quot;slope&quot;</span>
          ))
<span class="co"># calculate average slope per sub-catchment of each stream segment</span>
<span class="kw">calc_attributes_edges</span>(<span class="dt">input_raster =</span> <span class="st">&quot;slope&quot;</span>, <span class="dt">stat =</span> <span class="st">&quot;mean&quot;</span>,
                      <span class="dt">attr_name =</span> <span class="st">&quot;avSlo&quot;</span>, <span class="dt">round_dig =</span> <span class="dv">4</span>, <span class="dt">clean =</span> T)
<span class="co"># calculate approx. catchment area and average slope per catchment of each site</span>
<span class="kw">calc_attributes_sites_approx</span>(<span class="dt">sites_map =</span> <span class="st">&quot;sites&quot;</span>,
                             <span class="dt">input_attr_name =</span> <span class="st">&quot;avSlo&quot;</span>,
                             <span class="dt">output_attr_name =</span> <span class="st">&quot;avSloA&quot;</span>,
                             <span class="dt">stat =</span> <span class="st">&quot;mean&quot;</span>)
sites &lt;-<span class="st"> </span><span class="kw">readVECT</span>(<span class="st">&quot;sites&quot;</span>, <span class="dt">ignore.stderr =</span> <span class="ot">TRUE</span>)
<span class="kw">head</span>(sites@data)</code></pre></div>
<p>The exact calculation of attribute values for the total catchment of each point can take quite long (depending on the number of points) because for each point the total catchment is first delineated based on the DEM and then intersected with the raster map(s) provided. Note that if no raster map is provided the total catchment area for each point is calculated.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># calculates slope from DEM as an example attribute</span>
<span class="kw">execGRASS</span>(<span class="st">&quot;r.slope.aspect&quot;</span>, <span class="dt">flags =</span> <span class="kw">c</span>(<span class="st">&quot;overwrite&quot;</span>,<span class="st">&quot;quiet&quot;</span>),
          <span class="dt">parameters =</span> <span class="kw">list</span>(
            <span class="dt">elevation =</span> <span class="st">&quot;dem&quot;</span>,
            <span class="dt">slope =</span> <span class="st">&quot;slope&quot;</span>
          ))
<span class="co"># calculate exact catchment area and average slope per catchment of each site</span>
<span class="kw">calc_attributes_sites_exact</span>(<span class="dt">sites_map =</span> <span class="st">&quot;sites&quot;</span>, 
                            <span class="dt">input_raster =</span> <span class="st">&quot;slope&quot;</span>,
                            <span class="dt">stat =</span> <span class="st">&quot;mean&quot;</span>,
                            <span class="dt">attr_name =</span> <span class="st">&quot;avSloE&quot;</span>, 
                            <span class="dt">round_dig =</span> <span class="dv">4</span>)
sites &lt;-<span class="st"> </span><span class="kw">readVECT</span>(<span class="st">&quot;sites&quot;</span>, <span class="dt">ignore.stderr =</span> <span class="ot">TRUE</span>)
<span class="kw">head</span>(sites@data)</code></pre></div>
<p>In both alternatives, the catchment area for each site is calculated automatically (‘H2OAreaA’ for <code>calc_attributes_sites_appox</code> and ‘H2OArea’ for <code>calc_attributes_sites_exact</code>).</p>
</div>
<div id="write-all-files-to-an-ssn-folder" class="section level4">
<h4>Write all files to an ssn folder</h4>
<p>All files needed (edges, sites and optionally prediction sites) are written to the file path provided and can then be read in by the SSN package.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ssn_dir &lt;-<span class="st"> </span><span class="kw">file.path</span>(<span class="kw">tempdir</span>(), <span class="st">'nc.ssn'</span>)
<span class="kw">export_ssn</span>(ssn_dir)
<span class="kw">list.files</span>(ssn_dir)</code></pre></div>
</div>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
